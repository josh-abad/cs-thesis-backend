{"version":3,"sources":["webpack:///./src/components/Webcam/Webcam.vue?1a6c","webpack:///./src/components/Webcam/Webcam.vue","webpack:///./src/components/Webcam/components/EyeIcon.vue","webpack:///./src/components/Webcam/components/EyeIcon.vue?9ce1","webpack:///./src/components/Webcam/components/EyeIcon.vue?cc07","webpack:///./node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack:///./node_modules/@babel/runtime/helpers/esm/createClass.js","webpack:///./src/types/index.ts","webpack:///./src/components/Webcam/Webcam.vue?b1ff","webpack:///./src/components/Webcam/Webcam.vue?97bb","webpack:///./src/components/Webcam/components/EyeIcon.vue?3477","webpack:///./src/views/WebcamTest.vue","webpack:///./src/components/ToggleButton.vue","webpack:///./src/components/ToggleButton.vue?9944","webpack:///./src/components/ToggleButton.vue?ad61","webpack:///./src/views/WebcamTest.vue?1a4f","webpack:///./src/views/WebcamTest.vue?e57b"],"names":["class","ref","width","height","autoplay","muted","on","cameraOn","detected","faceSeen","identified","faceIdentified","debug","hideVideo","detectionTimer","remaining","status","identificationTimer","stroke-linecap","stroke-linejoin","stroke-width","d","fill","viewBox","stroke","name","props","type","Boolean","default","render","__scopeId","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","callback","duration","start","this","_remaining","_start","Date","now","timerId","window","setTimeout","_status","clearTimeout","Math","floor","USE_TINY_MODEL","MODELS_URL","components","EyeIcon","mixins","user","detectionDuration","Number","emits","data","multipleFacesSeen","usersSeen","video","computed","userName","fullName","includes","watch","isFaceSeen","stop","resume","pause","isFaceIdentified","mounted","detectionTimeout","identificationTimeout","$refs","loadModels","createFaceMatcher","faceMatcher","addEventListener","startDetection","startVideo","unmounted","stopVideo","methods","$emit","Promise","all","setInterval","inputSize","withFaceLandmarks","withFaceDescriptors","detections","results","map","fd","findBestMatch","match","toString","navigator","mediaDevices","getUserMedia","stream","srcObject","play","$store","dispatch","getTracks","forEach","track","imgUrl","referenceImageUrl","encodeURI","img","withFaceDescriptor","detection","Error","labeledDescriptor","maxDescriptorDistance","fill-rule","clip-rule","to","handleNoFaceSeen","handleUnidentifiedFace","detection-duration","hide-video","warnings","label","for","modelValue","value","$event","checked","id","disabled","required","String","BaseButton","Webcam","BasePanel","ToggleButton"],"mappings":"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","file":"js/chunk-8c0ae5f4.e9760950.js","sourcesContent":["export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./Webcam.vue?vue&type=style&index=0&id=820b8dc6&lang=postcss&scoped=true\"","<template>\n  <div>\n    <div class=\"flex items-center\">\n      <EyeIcon\n        :on=\"cameraOn\"\n        :detected=\"faceSeen\"\n        :identified=\"faceIdentified\"\n      />\n      <div class=\"ml-2\" v-if=\"debug\">\n        {{\n          faceIdentified\n            ? \"Face Identified\"\n            : faceSeen\n            ? \"Face Detected\"\n            : \"No Face detected\"\n        }}\n      </div>\n    </div>\n    <video\n      v-show=\"cameraOn && !hideVideo\"\n      ref=\"video\"\n      width=\"100\"\n      height=\"60\"\n      autoplay\n      muted\n    />\n    <div class=\"webcam-timer-display\" v-if=\"debug\">\n      <div class=\"timer\">\n        <h3 class=\"timer-header\">Detection Timer</h3>\n        <div class=\"timer-remaining\">\n          Remaining: {{ detectionTimer?.remaining ?? 0 }} seconds\n        </div>\n        <div class=\"timer-status\">\n          Status: {{ detectionTimer?.status ?? \"stopped\" }}\n        </div>\n      </div>\n      <div class=\"timer\">\n        <h3 class=\"timer-header\">Identification Timer</h3>\n        <div class=\"timer-remaining\">\n          Remaining: {{ identificationTimer?.remaining ?? 0 }} seconds\n        </div>\n        <div class=\"timer-status\">\n          Status: {{ identificationTimer?.status ?? \"stopped\" }}\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\nimport * as faceapi from 'face-api.js'\nimport { TinyFaceDetectorOptions, TNetInput } from 'face-api.js'\nimport { ALERT } from '@/store/action-types'\nimport userMixin from '@/mixins/user'\nimport EyeIcon from './components/EyeIcon.vue'\nimport { WebcamTimer } from '@/types'\n\nconst USE_TINY_MODEL = true\nconst MODELS_URL = '/models'\n\nexport default defineComponent({\n  name: 'Webcam',\n  components: { EyeIcon },\n  mixins: [userMixin],\n  props: {\n    hideVideo: {\n      type: Boolean,\n      default: false\n    },\n\n    detectionDuration: {\n      type: Number,\n      default: 5\n    },\n\n    debug: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['no-face-seen', 'unidentified-face'],\n  data () {\n    return {\n      faceSeen: false,\n      multipleFacesSeen: 0,\n      usersSeen: [] as string[],\n      video: {} as HTMLMediaElement,\n      cameraOn: false,\n      detectionTimer: null as WebcamTimer | null,\n      identificationTimer: null as WebcamTimer | null\n    }\n  },\n  computed: {\n    userName (): string {\n      return this.user?.fullName || ''\n    },\n\n    faceIdentified (): boolean {\n      return this.usersSeen.length === 1 && this.usersSeen[0].includes(this.userName)\n    },\n\n    duration (): number {\n      return this.detectionDuration * 1000\n    }\n  },\n  watch: {\n    faceSeen (isFaceSeen: boolean): void {\n      if (this.detectionTimer) {\n        if (isFaceSeen) {\n          this.detectionTimer.stop()\n          if (this.identificationTimer?.status === 'paused') {\n            this.identificationTimer && this.identificationTimer.resume()\n          }\n        } else if (['stopped', 'paused'].includes(this.detectionTimer.status)) {\n          this.detectionTimer.start()\n          this.identificationTimer && this.identificationTimer.pause()\n        }\n      }\n    },\n    faceIdentified (isFaceIdentified: boolean): void {\n      if (this.identificationTimer) {\n        if (isFaceIdentified) {\n          this.identificationTimer.stop()\n        } else if (['stopped', 'paused'].includes(this.identificationTimer.status) && this.detectionTimer?.status === 'stopped') {\n          this.identificationTimer.start()\n        }\n      }\n    }\n  },\n  async mounted () {\n    this.detectionTimer = new WebcamTimer(this.detectionTimeout, this.duration)\n    this.identificationTimer = new WebcamTimer(this.identificationTimeout, this.duration)\n\n    this.video = this.$refs.video as HTMLMediaElement\n\n    await this.loadModels()\n\n    const faceMatcher = await this.createFaceMatcher()\n    if (!faceMatcher) return\n\n    this.video.addEventListener('play', this.startDetection(faceMatcher))\n\n    await this.startVideo()\n    this.detectionTimer.start()\n  },\n  unmounted () {\n    this.stopVideo()\n    this.detectionTimer && this.detectionTimer.stop()\n    this.identificationTimer && this.identificationTimer.stop()\n  },\n  methods: {\n    detectionTimeout (): void {\n      this.$emit('no-face-seen')\n      this.detectionTimer && this.detectionTimer.start()\n    },\n    identificationTimeout (): void {\n      this.$emit('unidentified-face')\n      this.identificationTimer && this.identificationTimer.start()\n    },\n    async loadModels (): Promise<void> {\n      await Promise.all([\n        faceapi.loadTinyFaceDetectorModel(MODELS_URL),\n        faceapi.loadFaceLandmarkTinyModel(MODELS_URL),\n        faceapi.loadFaceRecognitionModel(MODELS_URL)\n      ])\n    },\n    startDetection (faceMatcher: faceapi.FaceMatcher): () => void {\n      return () => {\n        setInterval(async () => {\n          const detections = await faceapi\n            .detectAllFaces(this.video as TNetInput, new TinyFaceDetectorOptions({ inputSize: 128 }))\n            .withFaceLandmarks(USE_TINY_MODEL)\n            .withFaceDescriptors()\n\n          const results = detections.map(fd => faceMatcher.findBestMatch(fd.descriptor))\n\n          this.faceSeen = !!detections.length\n          this.usersSeen = results.map(match => match.toString())\n          this.multipleFacesSeen = detections.length\n        }, 300)\n      }\n    },\n    async startVideo (): Promise<void> {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({ video: {} })\n        this.video.srcObject = stream\n        this.video.play()\n        this.cameraOn = true\n      } catch (error) {\n        this.$store.dispatch(ALERT, error)\n      }\n    },\n    stopVideo (): void {\n      const stream = this.video?.srcObject as MediaStream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop())\n        this.cameraOn = false\n      }\n    },\n    async createFaceMatcher (): Promise<faceapi.FaceMatcher | null> {\n      const imgUrl = this.user?.referenceImageUrl\n\n      if (!imgUrl) return null\n\n      try {\n        const img = await faceapi.fetchImage(encodeURI(imgUrl))\n        const detection = await faceapi\n          .detectSingleFace(img, new TinyFaceDetectorOptions())\n          .withFaceLandmarks(USE_TINY_MODEL)\n          .withFaceDescriptor()\n\n        if (!detection) {\n          throw new Error(`No face detected for ${this.userName}.`)\n        }\n\n        const descriptor = [detection.descriptor]\n        const labeledDescriptor = new faceapi.LabeledFaceDescriptors(this.userName || 'unknown', descriptor)\n\n        const maxDescriptorDistance = 0.6\n        return new faceapi.FaceMatcher(labeledDescriptor, maxDescriptorDistance)\n      } catch (error) {\n        return null\n      }\n    }\n  }\n})\n</script>\n\n<style lang=\"postcss\" scoped>\n.timer-header {\n  @apply font-semibold;\n}\n</style>\n","<template>\n  <div class=\"icon\">\n    <!-- Heroicon name: eye  -->\n    <svg\n      v-if=\"on\"\n      :class=\"{\n        'icon-detected': detected,\n        'icon-identified': identified,\n      }\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n    >\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        stroke-width=\"2\"\n        d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\"\n      />\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        stroke-width=\"2\"\n        d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\"\n      />\n    </svg>\n    <!-- Heroicon name: eye-off -->\n    <svg v-else fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n      <path\n        stroke-linecap=\"round\"\n        stroke-linejoin=\"round\"\n        stroke-width=\"2\"\n        d=\"M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21\"\n      />\n    </svg>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'EyeIcon',\n  props: {\n    on: {\n      type: Boolean,\n      default: false\n    },\n\n    detected: {\n      type: Boolean,\n      default: false\n    },\n\n    identified: {\n      type: Boolean,\n      default: false\n    }\n  }\n})\n</script>\n\n<style lang=\"postcss\" scoped>\n.icon {\n  @apply w-10 h-10 text-gray-500;\n}\n\n.icon-detected {\n  @apply text-white;\n}\n\n.icon-identified {\n  @apply text-green-500;\n}\n</style>\n","\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'EyeIcon',\n  props: {\n    on: {\n      type: Boolean,\n      default: false\n    },\n\n    detected: {\n      type: Boolean,\n      default: false\n    },\n\n    identified: {\n      type: Boolean,\n      default: false\n    }\n  }\n})\n","import { render } from \"./EyeIcon.vue?vue&type=template&id=1985fbe8&scoped=true\"\nimport script from \"./EyeIcon.vue?vue&type=script&lang=ts\"\nexport * from \"./EyeIcon.vue?vue&type=script&lang=ts\"\n\nimport \"./EyeIcon.vue?vue&type=style&index=0&id=1985fbe8&lang=postcss&scoped=true\"\nscript.render = render\nscript.__scopeId = \"data-v-1985fbe8\"\n\nexport default script","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export type Role = 'student' | 'coordinator' | 'admin'\n\nexport interface User {\n  id: string;\n  name: {\n    first: string;\n    last: string;\n  };\n  fullName: string;\n  courses: string[];\n  email: string;\n  verified: boolean;\n  avatarUrl: string;\n  referenceImageUrl?: string;\n  role: Role;\n}\n\nexport interface AuthenticatedUser extends User {\n  token: string;\n}\n\nexport interface UserCredentials {\n  name: {\n    first: string;\n    last: string;\n  };\n  email: string;\n  password: string;\n}\n\nexport interface Course {\n  id: string;\n  name: string;\n  description: string;\n  exams: string[];\n  coordinator: Omit<User, 'token'>;\n  studentsEnrolled: string[];\n  weeks: number;\n}\n\nexport interface NewCourse extends Omit<Course, 'id' | 'coordinator' | 'studentsEnrolled' | 'exams'> {\n  coordinatorId: string;\n}\n\nexport interface Exam {\n  label: string;\n  examItems: ExamItem[];\n  random: boolean;\n  length: number;\n  duration: number;\n  course: Course;\n  maxAttempts: number;\n  week: number;\n  startDate: Date;\n  endDate: Date;\n  id: string;\n}\n\nexport interface NewExam extends Omit<Exam, 'id' | 'course'> {\n  courseId: string;\n}\n\nexport interface Answer {\n  question: string;\n  answer: string;\n}\n\nexport interface Submission {\n  answers: Answer[];\n  examId: string;\n  submittedDate?: Date;\n}\n\nexport interface Attempt {\n  id: string;\n  exam: Exam;\n  user: string;\n  status: 'in-progress' | 'completed';\n  startDate: Date;\n  endDate: Date;\n  submittedDate: Date;\n  examResult?: string;\n  score: number;\n  examTotal: number;\n}\n\nexport interface ExamItem {\n  question: string;\n  questionType: QuestionType;\n  answer: string[];\n  choices: string[];\n}\n\nexport type QuestionType = 'multiple choice' | 'text' | 'multiple answers'\n\nexport interface Score {\n  examItem: string;\n  points: number;\n}\n\nexport interface ExamResult {\n  id: string;\n  exam: string;\n  user: User;\n  scores: Score[];\n  attempt: string;\n}\n\nexport interface Link {\n  name: string;\n  url: string;\n}\n\nexport interface Option {\n  text: string;\n  value: string;\n}\n\nexport interface AppEvent {\n  subject: string;\n  subjectUrl: string;\n  subjectId: string;\n  predicate?: string;\n  predicateUrl?: string;\n  action: string;\n  location: string;\n  locationUrl: string;\n  date: Date;\n}\n\nexport type RootState = {\n  user: AuthenticatedUser | null;\n}\n\nexport type UsersState = {\n  users: User[];\n}\n\nexport type CoursesState = {\n  courses: Course[];\n  recentCourses: string[];\n}\n\nexport type ExamsState = {\n  exams: Exam[];\n  attempts: Attempt[];\n  examResults: ExamResult[];\n  activeExam: string | null;\n}\n\nexport type AlertState = {\n  message: string;\n}\n\nexport class WebcamTimer {\n  private _start: number\n  private _remaining: number\n  private _status: 'active' | 'stopped' | 'paused'\n  private timerId: number | null\n  private callback: () => void\n  private duration: number\n\n  constructor (callback: () => void, duration: number, start = false) {\n    this._remaining = duration\n    this.callback = callback\n    this.duration = duration\n    this._start = start ? Date.now() : 0\n    this.timerId = start ? window.setTimeout(this.callback, duration) : null\n    this._status = start ? 'active' : 'stopped'\n  }\n\n  start (): void {\n    this.timerId && clearTimeout(this.timerId)\n    this._start = Date.now()\n    this.timerId = window.setTimeout(this.callback, this.duration)\n    this._status = 'active'\n  }\n\n  stop (): void {\n    if (this._status === 'active') {\n      this.timerId && clearTimeout(this.timerId)\n      this._remaining = 0\n      this._status = 'stopped'\n    }\n  }\n\n  pause (): void {\n    if (this._status === 'active') {\n      this.timerId && clearTimeout(this.timerId)\n      this._remaining = this.duration - (Date.now() - this._start)\n      this._status = 'paused'\n    }\n  }\n\n  resume (): void {\n    if (this._status === 'paused') {\n      this.timerId && clearTimeout(this.timerId)\n      this._start = Date.now()\n      this.timerId = window.setTimeout(this.callback, this._remaining)\n      this._status = 'active'\n    }\n  }\n\n  get remaining (): number {\n    if (this._status === 'paused') {\n      return Math.floor(this._remaining / 1000)\n    } else if (this._status === 'active') {\n      return Math.floor((this.duration - (Date.now() - this._start)) / 1000)\n    }\n    return 0\n  }\n\n  get status (): 'active' | 'paused' | 'stopped' {\n    return this._status\n  }\n}\n","\nimport { defineComponent } from 'vue'\nimport * as faceapi from 'face-api.js'\nimport { TinyFaceDetectorOptions, TNetInput } from 'face-api.js'\nimport { ALERT } from '@/store/action-types'\nimport userMixin from '@/mixins/user'\nimport EyeIcon from './components/EyeIcon.vue'\nimport { WebcamTimer } from '@/types'\n\nconst USE_TINY_MODEL = true\nconst MODELS_URL = '/models'\n\nexport default defineComponent({\n  name: 'Webcam',\n  components: { EyeIcon },\n  mixins: [userMixin],\n  props: {\n    hideVideo: {\n      type: Boolean,\n      default: false\n    },\n\n    detectionDuration: {\n      type: Number,\n      default: 5\n    },\n\n    debug: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['no-face-seen', 'unidentified-face'],\n  data () {\n    return {\n      faceSeen: false,\n      multipleFacesSeen: 0,\n      usersSeen: [] as string[],\n      video: {} as HTMLMediaElement,\n      cameraOn: false,\n      detectionTimer: null as WebcamTimer | null,\n      identificationTimer: null as WebcamTimer | null\n    }\n  },\n  computed: {\n    userName (): string {\n      return this.user?.fullName || ''\n    },\n\n    faceIdentified (): boolean {\n      return this.usersSeen.length === 1 && this.usersSeen[0].includes(this.userName)\n    },\n\n    duration (): number {\n      return this.detectionDuration * 1000\n    }\n  },\n  watch: {\n    faceSeen (isFaceSeen: boolean): void {\n      if (this.detectionTimer) {\n        if (isFaceSeen) {\n          this.detectionTimer.stop()\n          if (this.identificationTimer?.status === 'paused') {\n            this.identificationTimer && this.identificationTimer.resume()\n          }\n        } else if (['stopped', 'paused'].includes(this.detectionTimer.status)) {\n          this.detectionTimer.start()\n          this.identificationTimer && this.identificationTimer.pause()\n        }\n      }\n    },\n    faceIdentified (isFaceIdentified: boolean): void {\n      if (this.identificationTimer) {\n        if (isFaceIdentified) {\n          this.identificationTimer.stop()\n        } else if (['stopped', 'paused'].includes(this.identificationTimer.status) && this.detectionTimer?.status === 'stopped') {\n          this.identificationTimer.start()\n        }\n      }\n    }\n  },\n  async mounted () {\n    this.detectionTimer = new WebcamTimer(this.detectionTimeout, this.duration)\n    this.identificationTimer = new WebcamTimer(this.identificationTimeout, this.duration)\n\n    this.video = this.$refs.video as HTMLMediaElement\n\n    await this.loadModels()\n\n    const faceMatcher = await this.createFaceMatcher()\n    if (!faceMatcher) return\n\n    this.video.addEventListener('play', this.startDetection(faceMatcher))\n\n    await this.startVideo()\n    this.detectionTimer.start()\n  },\n  unmounted () {\n    this.stopVideo()\n    this.detectionTimer && this.detectionTimer.stop()\n    this.identificationTimer && this.identificationTimer.stop()\n  },\n  methods: {\n    detectionTimeout (): void {\n      this.$emit('no-face-seen')\n      this.detectionTimer && this.detectionTimer.start()\n    },\n    identificationTimeout (): void {\n      this.$emit('unidentified-face')\n      this.identificationTimer && this.identificationTimer.start()\n    },\n    async loadModels (): Promise<void> {\n      await Promise.all([\n        faceapi.loadTinyFaceDetectorModel(MODELS_URL),\n        faceapi.loadFaceLandmarkTinyModel(MODELS_URL),\n        faceapi.loadFaceRecognitionModel(MODELS_URL)\n      ])\n    },\n    startDetection (faceMatcher: faceapi.FaceMatcher): () => void {\n      return () => {\n        setInterval(async () => {\n          const detections = await faceapi\n            .detectAllFaces(this.video as TNetInput, new TinyFaceDetectorOptions({ inputSize: 128 }))\n            .withFaceLandmarks(USE_TINY_MODEL)\n            .withFaceDescriptors()\n\n          const results = detections.map(fd => faceMatcher.findBestMatch(fd.descriptor))\n\n          this.faceSeen = !!detections.length\n          this.usersSeen = results.map(match => match.toString())\n          this.multipleFacesSeen = detections.length\n        }, 300)\n      }\n    },\n    async startVideo (): Promise<void> {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({ video: {} })\n        this.video.srcObject = stream\n        this.video.play()\n        this.cameraOn = true\n      } catch (error) {\n        this.$store.dispatch(ALERT, error)\n      }\n    },\n    stopVideo (): void {\n      const stream = this.video?.srcObject as MediaStream\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop())\n        this.cameraOn = false\n      }\n    },\n    async createFaceMatcher (): Promise<faceapi.FaceMatcher | null> {\n      const imgUrl = this.user?.referenceImageUrl\n\n      if (!imgUrl) return null\n\n      try {\n        const img = await faceapi.fetchImage(encodeURI(imgUrl))\n        const detection = await faceapi\n          .detectSingleFace(img, new TinyFaceDetectorOptions())\n          .withFaceLandmarks(USE_TINY_MODEL)\n          .withFaceDescriptor()\n\n        if (!detection) {\n          throw new Error(`No face detected for ${this.userName}.`)\n        }\n\n        const descriptor = [detection.descriptor]\n        const labeledDescriptor = new faceapi.LabeledFaceDescriptors(this.userName || 'unknown', descriptor)\n\n        const maxDescriptorDistance = 0.6\n        return new faceapi.FaceMatcher(labeledDescriptor, maxDescriptorDistance)\n      } catch (error) {\n        return null\n      }\n    }\n  }\n})\n","import { render } from \"./Webcam.vue?vue&type=template&id=820b8dc6&scoped=true\"\nimport script from \"./Webcam.vue?vue&type=script&lang=ts\"\nexport * from \"./Webcam.vue?vue&type=script&lang=ts\"\n\nimport \"./Webcam.vue?vue&type=style&index=0&id=820b8dc6&lang=postcss&scoped=true\"\nscript.render = render\nscript.__scopeId = \"data-v-820b8dc6\"\n\nexport default script","export * from \"-!../../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./EyeIcon.vue?vue&type=style&index=0&id=1985fbe8&lang=postcss&scoped=true\"","<template>\n  <div class=\"p-4\">\n    <teleport to=\"#modals\">\n      <div\n        class=\"mr-8 bg-dark-12 px-4 py-2 fixed bottom-0 right-0 z-20 rounded-t-lg shadow-lg flex space-x-2\"\n      >\n        <Webcam\n          @no-face-seen=\"handleNoFaceSeen\"\n          @unidentified-face=\"handleUnidentifiedFace\"\n          :detection-duration=\"10\"\n          :debug=\"debug\"\n          :hide-video=\"!video\"\n        />\n        <div class=\"text-red-400 inline-flex items-center\">\n          <!-- Heroicon name: exclamation -->\n          <svg class=\"w-10 h-10\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\"\n              clip-rule=\"evenodd\"\n            />\n          </svg>\n          {{ warnings }}\n        </div>\n      </div>\n    </teleport>\n    <BasePanel>\n      <div class=\"flex flex-col items-start\">\n        <BaseButton @click=\"warnings = 0\">Reset Warnings</BaseButton>\n        <ToggleButton v-model=\"debug\" label=\"Debug\" />\n        <ToggleButton v-model=\"video\" label=\"Show Video\" />\n      </div>\n      <div v-for=\"i in 25\" :key=\"i\">foo</div>\n    </BasePanel>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport BaseButton from '@/components/BaseButton.vue'\nimport BasePanel from '@/components/BasePanel.vue'\nimport ToggleButton from '@/components/ToggleButton.vue'\nimport Webcam from '@/components/Webcam/Webcam.vue'\nimport { ALERT } from '@/store/action-types'\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'WebcamTest',\n  components: { BaseButton, Webcam, BasePanel, ToggleButton },\n  data () {\n    return {\n      warnings: 0,\n      debug: false,\n      video: false\n    }\n  },\n  methods: {\n    handleNoFaceSeen (): void {\n      this.warnings++\n      this.$store.dispatch(ALERT, 'No face seen for 10 seconds.')\n    },\n    handleUnidentifiedFace (): void {\n      this.warnings++\n      this.$store.dispatch(ALERT, 'Face unidentified for 10 seconds')\n    }\n  }\n})\n</script>\n","<template>\n  <label\n    :for=\"label\"\n    class=\"mt-3 inline-flex items-center\"\n    :class=\"\n      disabled ? 'opacity-50 cursor-default' : 'opacity-100 cursor-pointer'\n    \"\n  >\n    <span class=\"relative\">\n      <span\n        class=\"block w-10 h-6 rounded-full shadow-inner\"\n        :class=\"modelValue ? 'bg-green-500' : 'bg-gray-600'\"\n      ></span>\n      <span\n        class=\"absolute block w-4 h-4 mt-1 ml-1 bg-white rounded-full shadow-lg inset-y-0 left-0 focus-within:shadow-outline transition-transform duration-300 ease-in-out\"\n        :class=\"modelValue ? 'transform translate-x-full' : ''\"\n      >\n        <input\n          :value=\"modelValue\"\n          @change=\"$emit('update:modelValue', $event.target.checked)\"\n          :id=\"label\"\n          :disabled=\"disabled\"\n          type=\"checkbox\"\n          class=\"absolute opacity-0 w-0 h-0\"\n        />\n      </span>\n    </span>\n    <span class=\"ml-3 text-sm\">{{ label }}</span>\n  </label>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'ToggleButton',\n  props: {\n    modelValue: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    label: {\n      type: String,\n      required: false,\n      default: ''\n    },\n    disabled: {\n      type: Boolean,\n      required: false,\n      default: false\n    }\n  },\n  emits: ['update:modelValue']\n})\n</script>\n","\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'ToggleButton',\n  props: {\n    modelValue: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    label: {\n      type: String,\n      required: false,\n      default: ''\n    },\n    disabled: {\n      type: Boolean,\n      required: false,\n      default: false\n    }\n  },\n  emits: ['update:modelValue']\n})\n","import { render } from \"./ToggleButton.vue?vue&type=template&id=6a861d6f\"\nimport script from \"./ToggleButton.vue?vue&type=script&lang=ts\"\nexport * from \"./ToggleButton.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script","\nimport BaseButton from '@/components/BaseButton.vue'\nimport BasePanel from '@/components/BasePanel.vue'\nimport ToggleButton from '@/components/ToggleButton.vue'\nimport Webcam from '@/components/Webcam/Webcam.vue'\nimport { ALERT } from '@/store/action-types'\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  name: 'WebcamTest',\n  components: { BaseButton, Webcam, BasePanel, ToggleButton },\n  data () {\n    return {\n      warnings: 0,\n      debug: false,\n      video: false\n    }\n  },\n  methods: {\n    handleNoFaceSeen (): void {\n      this.warnings++\n      this.$store.dispatch(ALERT, 'No face seen for 10 seconds.')\n    },\n    handleUnidentifiedFace (): void {\n      this.warnings++\n      this.$store.dispatch(ALERT, 'Face unidentified for 10 seconds')\n    }\n  }\n})\n","import { render } from \"./WebcamTest.vue?vue&type=template&id=57e25df0\"\nimport script from \"./WebcamTest.vue?vue&type=script&lang=ts\"\nexport * from \"./WebcamTest.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script"],"sourceRoot":""}